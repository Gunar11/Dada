#!/usr/bin/env python3
"""
Telegram Bot - Eisenhower Task Planner
Matrix-based task manager with reminders and motivation
"""

import logging
import sqlite3
from datetime import datetime, timedelta
import requests
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from io import BytesIO
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore

# ===== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø =====
BOT_TOKEN = "YOUR_BOT_TOKEN_HERE"
DB_PATH = "eisenhower_planner.db"
QUOTE_API_URL = "https://zenquotes.io/api/random"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ===== –û–ü–ò–°–ê–ù–ò–Ø –ö–ê–¢–ï–ì–û–†–ò–ô =====
CATEGORY_INFO = {
    'important_urgent': {
        'name': 'üö® –í–∞–∂–Ω—ã–µ –∏ —Å—Ä–æ—á–Ω—ã–µ',
        'description': '–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏, —Ç—Ä–µ–±—É—é—â–∏–µ –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –≤–Ω–∏–º–∞–Ω–∏—è. –î–µ–ª–∞, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ–ª—å–∑—è –æ—Ç–ª–æ–∂–∏—Ç—å.',
        'examples': ['‚Ä¢ –°—Ä–æ—á–Ω—ã–π –¥–µ–¥–ª–∞–π–Ω –ø–æ –ø—Ä–æ–µ–∫—Ç—É\n‚Ä¢ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–±–ª–µ–º–∞ —Å–æ –∑–¥–æ—Ä–æ–≤—å–µ–º\n‚Ä¢ –ê–≤—Ç–æ–º–æ–±–∏–ª—å —Å–ª–æ–º–∞–ª—Å—è']
    },
    'important_not_urgent': {
        'name': 'üéØ –í–∞–∂–Ω—ã–µ, –Ω–æ –Ω–µ —Å—Ä–æ—á–Ω—ã–µ',
        'description': '–°—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏ –¥–ª—è –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–≥–æ —Ä–∞–∑–≤–∏—Ç–∏—è. –°–∞–º—ã–µ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏!',
        'examples': ['‚Ä¢ –ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ü–µ–ª–µ–π\n‚Ä¢ –û–±—É—á–µ–Ω–∏–µ –Ω–æ–≤—ã–º –Ω–∞–≤—ã–∫–∞–º\n‚Ä¢ –†–µ–≥—É–ª—è—Ä–Ω—ã–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏']
    },
    'not_important_urgent': {
        'name': 'üìÖ –°—Ä–æ—á–Ω—ã–µ, –Ω–æ –Ω–µ –≤–∞–∂–Ω—ã–µ',
        'description': '–û—Ç–≤–ª–µ–∫–∞—é—â–∏–µ —Ñ–∞–∫—Ç–æ—Ä—ã, –∫–æ—Ç–æ—Ä—ã–µ —Å–æ–∑–¥–∞—é—Ç –∏–ª–ª—é–∑–∏—é –∑–∞–Ω—è—Ç–æ—Å—Ç–∏. –ß–∞—Å—Ç–æ –º–æ–∂–Ω–æ –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞—Ç—å.',
        'examples': ['‚Ä¢ –í–Ω–µ–∑–∞–ø–Ω—ã–µ –∑–≤–æ–Ω–∫–∏\n‚Ä¢ –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –≤—Å—Ç—Ä–µ—á–∏\n‚Ä¢ –†—É—Ç–∏–Ω–Ω—ã–µ –ø–æ—Ä—É—á–µ–Ω–∏—è']
    },
    'not_important_not_urgent': {
        'name': '‚è≥ –ù–µ —Å—Ä–æ—á–Ω—ã–µ –∏ –Ω–µ –≤–∞–∂–Ω—ã–µ',
        'description': '–ü–æ–≥–ª–æ—Ç–∏—Ç–µ–ª–∏ –≤—Ä–µ–º–µ–Ω–∏. –ú–∏–Ω–∏–º–∏–∑–∏—Ä—É–π—Ç–µ —ç—Ç–∏ –∑–∞–Ω—è—Ç–∏—è.',
        'examples': ['‚Ä¢ –°–æ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–µ—Ç–∏\n‚Ä¢ –ë–µ—Å—Ü–µ–ª—å–Ω—ã–π —Å–µ—Ä—Ñ–∏–Ω–≥ –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–µ\n‚Ä¢ –ß—Ä–µ–∑–º–µ—Ä–Ω—ã–π –æ—Ç–¥—ã—Ö']
    }
}

# ===== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ë–ê–ó–´ –î–ê–ù–ù–´–• =====
def init_db():
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            reminder_time TEXT DEFAULT '09:00',
            registered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS tasks (
            task_id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            task_text TEXT NOT NULL,
            category TEXT NOT NULL CHECK(category IN ('important_urgent', 'important_not_urgent', 'not_important_urgent', 'not_important_not_urgent')),
            deadline TIMESTAMP,
            reminder_hours_before INTEGER DEFAULT 24,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            completed_at TIMESTAMP,
            is_completed BOOLEAN DEFAULT FALSE,
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )
    ''')
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS quotes (
            quote_id INTEGER PRIMARY KEY AUTOINCREMENT,
            quote_text TEXT NOT NULL,
            author TEXT,
            added_date DATE DEFAULT CURRENT_DATE
        )
    ''')
    
    conn.commit()
    conn.close()

# ===== –†–ê–ë–û–¢–ê –° –¶–ò–¢–ê–¢–ê–ú–ò =====
def get_daily_quote():
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        cursor.execute("SELECT quote_text, author FROM quotes WHERE added_date = DATE('now')")
        result = cursor.fetchone()
        
        if result:
            conn.close()
            return f"\"{result[0]}\"\n‚Äî {result[1]}"
        
        response = requests.get(QUOTE_API_URL, timeout=10)
        if response.status_code == 200:
            data = response.json()
            quote_text = data[0]['q']
            author = data[0]['a']
            
            cursor.execute(
                "INSERT INTO quotes (quote_text, author) VALUES (?, ?)",
                (quote_text, author)
            )
            conn.commit()
            conn.close()
            
            return f"\"{quote_text}\"\n‚Äî {author}"
    
    except Exception as e:
        logger.error(f"Error getting quote: {e}")
    
    return "¬´–°–∞–º–æ–µ –≤—Ä–µ–º—è —Å–¥–µ–ª–∞—Ç—å —á—Ç–æ-—Ç–æ –≤–∞–∂–Ω–æ–µ!¬ª\n‚Äî –í–∞—à –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫"

# ===== –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–Ø –ú–ê–¢–†–ò–¶–´ =====
def create_eisenhower_matrix(user_id):
    """–°–æ–∑–¥–∞–µ—Ç –≤–∏–∑—É–∞–ª—å–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã –≠–π–∑–µ–Ω—Ö–∞—É—ç—Ä–∞ —Å –∑–∞–¥–∞—á–∞–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    cursor.execute('''
        SELECT category, task_text, is_completed 
        FROM tasks 
        WHERE user_id = ? AND is_completed = FALSE
    ''', (user_id,))
    
    tasks = cursor.fetchall()
    conn.close()
    
    fig, ax = plt.subplots(figsize=(12, 8))
    
    ax.add_patch(patches.Rectangle((0, 0.5), 0.5, 0.5, fill=True, color='#ff6b6b', alpha=0.3))
    ax.add_patch(patches.Rectangle((0.5, 0.5), 0.5, 0.5, fill=True, color='#51cf66', alpha=0.3))
    ax.add_patch(patches.Rectangle((0, 0), 0.5, 0.5, fill=True, color='#ffd43b', alpha=0.3))
    ax.add_patch(patches.Rectangle((0.5, 0), 0.5, 0.5, fill=True, color='#868e96', alpha=0.3))
    
    ax.text(0.25, 0.75, 'üö® –í–ê–ñ–ù–´–ï\n–°–†–û–ß–ù–´–ï', ha='center', va='center', fontsize=14, weight='bold', color='#c92a2a')
    ax.text(0.75, 0.75, 'üéØ –í–ê–ñ–ù–´–ï\n–ù–ï–°–†–û–ß–ù–´–ï', ha='center', va='center', fontsize=14, weight='bold', color='#2b8a3e')
    ax.text(0.25, 0.25, 'üìÖ –ù–ï–í–ê–ñ–ù–´–ï\n–°–†–û–ß–ù–´–ï', ha='center', va='center', fontsize=14, weight='bold', color='#e67700')
    ax.text(0.75, 0.25, '‚è≥ –ù–ï–í–ê–ñ–ù–´–ï\n–ù–ï–°–†–û–ß–ù–´–ï', ha='center', va='center', fontsize=14, weight='bold', color='#495057')
    
    y_positions = {
        'important_urgent': [0.65, 0.60, 0.55, 0.50],
        'important_not_urgent': [0.65, 0.60, 0.55, 0.50],
        'not_important_urgent': [0.40, 0.35, 0.30, 0.25],
        'not_important_not_urgent': [0.40, 0.35, 0.30, 0.25]
    }
    
    task_counters = {category: 0 for category in CATEGORY_INFO.keys()}
    
    for category, task_text, is_completed in tasks:
        if task_counters[category] < 4:
            if category in ['important_urgent', 'not_important_urgent']:
                x = 0.1 if task_counters[category] % 2 == 0 else 0.3
            else:
                x = 0.6 if task_counters[category] % 2 == 0 else 0.8
            
            y = y_positions[category][task_counters[category] // 2]
            
            display_text = task_text[:20] + '...' if len(task_text) > 20 else task_text
            ax.text(x, y, f'‚Ä¢ {display_text}', fontsize=8, ha='left', va='center',
                   bbox=dict(boxstyle="round,pad=0.3", facecolor='white', alpha=0.8))
            
            task_counters[category] += 1
    
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)
    ax.axis('off')
    
    buf = BytesIO()
    plt.savefig(buf, format='png', dpi=80, bbox_inches='tight')
    buf.seek(0)
    plt.close()
    
    return buf

# ===== –ö–û–ú–ê–ù–î–´ –ë–û–¢–ê =====
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    cursor.execute(
        "INSERT OR IGNORE INTO users (user_id, username, first_name) VALUES (?, ?, ?)",
        (user.id, user.username, user.first_name)
    )
    conn.commit()
    conn.close()
    
    quote = get_daily_quote()
    welcome_text = f"""
–ü—Ä–∏–≤–µ—Ç, {user.first_name}! üëã

–Ø —Ç–≤–æ–π –ª–∏—á–Ω—ã–π –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –ø–æ *–ú–∞—Ç—Ä–∏—Ü–µ –≠–π–∑–µ–Ω—Ö–∞—É—ç—Ä–∞* - –º–æ—â–Ω–æ–º—É –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—É –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏.

*–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:*
/add - –î–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É —Å –¥–µ–¥–ª–∞–π–Ω–æ–º
/tasks - –ü–æ–∫–∞–∑–∞—Ç—å –º–æ–∏ –∑–∞–¥–∞—á–∏  
/matrix - –í–∏–∑—É–∞–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ –∑–∞–¥–∞—á
/complete - –û—Ç–º–µ—Ç–∏—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
/stats - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
/reminders - –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
/quote - –ú–æ—Ç–∏–≤–∞—Ü–∏–æ–Ω–Ω–∞—è —Ü–∏—Ç–∞—Ç–∞

*–°–µ–≥–æ–¥–Ω—è—à–Ω—è—è —Ü–∏—Ç–∞—Ç–∞:*
{quote}
"""
    
    await update.message.reply_text(welcome_text, parse_mode='Markdown')

async def show_quote(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /quote - –ø–æ–∫–∞–∑–∞—Ç—å –º–æ—Ç–∏–≤–∞—Ü–∏–æ–Ω–Ω—É—é —Ü–∏—Ç–∞—Ç—É"""
    quote = get_daily_quote()
    await update.message.reply_text(f"*–í–¥–æ—Ö–Ω–æ–≤–µ–Ω–∏–µ –¥–ª—è —Ç–µ–±—è:*\n\n{quote}", parse_mode='Markdown')

async def show_categories(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = "üìä *–ú–∞—Ç—Ä–∏—Ü–∞ –≠–π–∑–µ–Ω—Ö–∞—É—ç—Ä–∞ - –û–±—ä—è—Å–Ω–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–π:*\n\n"
    
    for category_key, info in CATEGORY_INFO.items():
        text += f"{info['name']}:\n"
        text += f"{info['description']}\n"
        text += f"*–ü—Ä–∏–º–µ—Ä—ã:*\n{info['examples']}\n\n"
    
    await update.message.reply_text(text, parse_mode='Markdown')

async def add_task(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("üö® –í–∞–∂–Ω—ã–µ –∏ —Å—Ä–æ—á–Ω—ã–µ", callback_data="category_important_urgent")],
        [InlineKeyboardButton("üéØ –í–∞–∂–Ω—ã–µ, –Ω–æ –Ω–µ —Å—Ä–æ—á–Ω—ã–µ", callback_data="category_important_not_urgent")],
        [InlineKeyboardButton("üìÖ –°—Ä–æ—á–Ω—ã–µ, –Ω–æ –Ω–µ –≤–∞–∂–Ω—ã–µ", callback_data="category_not_important_urgent")],
        [InlineKeyboardButton("‚è≥ –ù–µ —Å—Ä–æ—á–Ω—ã–µ –∏ –Ω–µ –≤–∞–∂–Ω—ã–µ", callback_data="category_not_important_not_urgent")],
        [InlineKeyboardButton("‚ùì –û–±—ä—è—Å–Ω–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–π", callback_data="explain_categories")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–ª—è –Ω–æ–≤–æ–π –∑–∞–¥–∞—á–∏:",
        reply_markup=reply_markup
    )

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    
    if query.data.startswith("category_"):
        category = query.data.replace("category_", "")
        context.user_data['awaiting_task'] = category
        context.user_data['task_stage'] = 'text'
        
        await query.edit_message_text(
            f"–í—ã–±—Ä–∞–Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—è: *{CATEGORY_INFO[category]['name']}*\n\n"
            f"*–û–ø–∏—Å–∞–Ω–∏–µ:* {CATEGORY_INFO[category]['description']}\n\n"
            "–¢–µ–ø–µ—Ä—å –Ω–∞–ø–∏—à–∏ —Ç–µ–∫—Å—Ç –∑–∞–¥–∞—á–∏:",
            parse_mode='Markdown'
        )
    
    elif query.data == "explain_categories":
        await show_categories_info(query)
    
    elif query.data.startswith("complete_"):
        task_id = int(query.data.replace("complete_", ""))
        await complete_task(query, task_id)
    
    elif query.data.startswith("reminder_"):
        time_str = query.data.replace("reminder_", "")
        await set_reminder_time(query, time_str)

async def show_categories_info(query):
    text = "üìä *–û–±—ä—è—Å–Ω–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –º–∞—Ç—Ä–∏—Ü—ã:*\n\n"
    
    for category_key, info in CATEGORY_INFO.items():
        text += f"{info['name']}:\n"
        text += f"{info['description']}\n"
        text += f"*–ü—Ä–∏–º–µ—Ä—ã:*\n{info['examples']}\n\n"
    
    keyboard = [[InlineKeyboardButton("¬´ –ù–∞–∑–∞–¥ –∫ –¥–æ–±–∞–≤–ª–µ–Ω–∏—é –∑–∞–¥–∞—á–∏", callback_data="back_to_categories")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(text, parse_mode='Markdown', reply_markup=reply_markup)

async def complete_task(query, task_id):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    cursor.execute(
        "UPDATE tasks SET is_completed = TRUE, completed_at = CURRENT_TIMESTAMP WHERE task_id = ?",
        (task_id,)
    )
    conn.commit()
    
    cursor.execute("SELECT task_text FROM tasks WHERE task_id = ?", (task_id,))
    task_text = cursor.fetchone()[0]
    conn.close()
    
    await query.edit_message_text(
        f"‚úÖ *–ó–∞–¥–∞—á–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞!*\n\n\"{task_text}\"\n\n"
        f"–û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞! –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –≤ —Ç–æ–º –∂–µ –¥—É—Ö–µ! üí™",
        parse_mode='Markdown'
    )

async def set_reminder_time(query, time_str):
    user_id = query.from_user.id
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    cursor.execute(
        "UPDATE users SET reminder_time = ? WHERE user_id = ?",
        (time_str, user_id)
    )
    conn.commit()
    conn.close()
    
    await query.edit_message_text(
        f"‚úÖ –í—Ä–µ–º—è –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –Ω–∞ *{time_str}*\n\n"
        f"–í—ã –±—É–¥–µ—Ç–µ –ø–æ–ª—É—á–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å–≤–æ–∏—Ö –∑–∞–¥–∞—á–∞—Ö –∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ —ç—Ç–æ –≤—Ä–µ–º—è.",
        parse_mode='Markdown'
    )

async def handle_task_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if 'task_stage' not in context.user_data:
        return
    
    user_id = update.effective_user.id
    task_stage = context.user_data['task_stage']
    
    if task_stage == 'text':
        context.user_data['task_text'] = update.message.text
        context.user_data['task_stage'] = 'deadline'
        
        keyboard = [
            [InlineKeyboardButton("‚è∞ –°–µ–≥–æ–¥–Ω—è", callback_data="deadline_today")],
            [InlineKeyboardButton("üìÖ –ó–∞–≤—Ç—Ä–∞", callback_data="deadline_tomorrow")],
            [InlineKeyboardButton("üóì –ß–µ—Ä–µ–∑ 3 –¥–Ω—è", callback_data="deadline_3days")],
            [InlineKeyboardButton("üìÜ –ß–µ—Ä–µ–∑ –Ω–µ–¥–µ–ª—é", callback_data="deadline_week")],
            [InlineKeyboardButton("‚è≥ –ë–µ–∑ –¥–µ–¥–ª–∞–π–Ω–∞", callback_data="deadline_none")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            "üìÖ –í—ã–±–µ—Ä–∏ –¥–µ–¥–ª–∞–π–Ω –¥–ª—è –∑–∞–¥–∞—á–∏:",
            reply_markup=reply_markup
        )
    
    elif task_stage == 'deadline_custom':
        try:
            deadline_date = datetime.strptime(update.message.text, '%d.%m.%Y %H:%M')
            await save_task_with_deadline(update, context, deadline_date)
        except ValueError:
            await update.message.reply_text(
                "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –ò—Å–ø–æ–ª—å–∑—É–π: –î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú\n–ù–∞–ø—Ä–∏–º–µ—Ä: 25.12.2024 14:30"
            )

async def handle_deadline_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data == "deadline_custom":
        context.user_data['task_stage'] = 'deadline_custom'
        await query.edit_message_text(
            "üìÖ –í–≤–µ–¥–∏ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n*–î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú*\n\n–ù–∞–ø—Ä–∏–º–µ—Ä: 25.12.2024 14:30",
            parse_mode='Markdown'
        )
        return
    
    deadline_map = {
        'deadline_today': datetime.now() + timedelta(hours=2),
        'deadline_tomorrow': datetime.now() + timedelta(days=1),
        'deadline_3days': datetime.now() + timedelta(days=3),
        'deadline_week': datetime.now() + timedelta(days=7),
        'deadline_none': None
    }
    
    deadline = deadline_map.get(query.data)
    await save_task_with_deadline(query, context, deadline)

async def save_task_with_deadline(update, context, deadline):
    user_id = update.effective_user.id if hasattr(update, 'effective_user') else update.from_user.id
    task_text = context.user_data['task_text']
    category = context.user_data['awaiting_task']
    
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    cursor.execute(
        "INSERT INTO tasks (user_id, task_text, category, deadline) VALUES (?, ?, ?, ?)",
        (user_id, task_text, category, deadline)
    )
    task_id = cursor.lastrowid
    conn.commit()
    conn.close()
    
    context.user_data.clear()
    
    deadline_text = deadline.strftime("%d.%m.%Y %H:%M") if deadline else "–Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
    
    response_text = (
        f"‚úÖ *–ó–∞–¥–∞—á–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞!*\n\n"
        f"*–ó–∞–¥–∞—á–∞:* {task_text}\n"
        f"*–ö–∞—Ç–µ–≥–æ—Ä–∏—è:* {CATEGORY_INFO[category]['name']}\n"
        f"*–î–µ–¥–ª–∞–π–Ω:* {deadline_text}\n\n"
        f"–ò—Å–ø–æ–ª—å–∑—É–π /tasks —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤—Å–µ –∑–∞–¥–∞—á–∏."
    )
    
    if hasattr(update, 'message'):
        await update.message.reply_text(response_text, parse_mode='Markdown')
    else:
        await update.edit_message_text(response_text, parse_mode='Markdown')

async def show_tasks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    cursor.execute('''
        SELECT task_id, task_text, category, deadline, is_completed 
        FROM tasks 
        WHERE user_id = ? AND is_completed = FALSE
        ORDER BY 
            CASE category
                WHEN 'important_urgent' THEN 1
                WHEN 'important_not_urgent' THEN 2
                WHEN 'not_important_urgent' THEN 3
                WHEN 'not_important_not_urgent' THEN 4
            END,
            deadline ASC
    ''', (user_id,))
    
    tasks = cursor.fetchall()
    conn.close()
    
    if not tasks:
        await update.message.reply_text(
            "üéâ –£ —Ç–µ–±—è –ø–æ–∫–∞ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á!\n\n"
            "–ò—Å–ø–æ–ª—å–∑—É–π /add —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –ø–µ—Ä–≤—É—é –∑–∞–¥–∞—á—É."
        )
        return
    
    tasks_by_category = {}
    for task in tasks:
        task_id, task_text, category, deadline, is_completed = task
        if category not in tasks_by_category:
            tasks_by_category[category] = []
        tasks_by_category[category].append((task_id, task_text, deadline))
    
    message = "üìã *–¢–≤–æ–∏ –∑–∞–¥–∞—á–∏ –ø–æ –º–∞—Ç—Ä–∏—Ü–µ –≠–π–∑–µ–Ω—Ö–∞—É—ç—Ä–∞:*\n\n"
    
    for category in CATEGORY_INFO.keys():
        if category in tasks_by_category:
            message += f"*{CATEGORY_INFO[category]['name']}:*\n"
            for task_id, task_text, deadline in tasks_by_category[category]:
                deadline_text = deadline.strftime("%d.%m.%Y %H:%M") if deadline else "–Ω–µ—Ç –¥–µ–¥–ª–∞–π–Ω–∞"
                message += f"‚Ä¢ {task_text}\n  ‚è∞ {deadline_text}\n"
            message += "\n"
    
    message += "\n–ò—Å–ø–æ–ª—å–∑—É–π /complete —á—Ç–æ–±—ã –æ—Ç–º–µ—Ç–∏—Ç—å –∑–∞–¥–∞—á–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–º–∏."
    
    await update.message.reply_text(message, parse_mode='Markdown')

async def show_matrix(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    matrix_image = create_eisenhower_matrix(user_id)
    
    caption = (
        "üìä *–í–∞—à–∞ –º–∞—Ç—Ä–∏—Ü–∞ –≠–π–∑–µ–Ω—Ö–∞—É—ç—Ä–∞*\n\n"
        "‚Ä¢ üö® **–í–∞–∂–Ω—ã–µ –∏ —Å—Ä–æ—á–Ω—ã–µ** - –°–¥–µ–ª–∞—Ç—å —Å—Ä–∞–∑—É\n"
        "‚Ä¢ üéØ **–í–∞–∂–Ω—ã–µ, –Ω–æ –Ω–µ —Å—Ä–æ—á–Ω—ã–µ** - –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å\n" 
        "‚Ä¢ üìÖ **–°—Ä–æ—á–Ω—ã–µ, –Ω–æ –Ω–µ –≤–∞–∂–Ω—ã–µ** - –î–µ–ª–µ–≥–∏—Ä–æ–≤–∞—Ç—å\n"
        "‚Ä¢ ‚è≥ **–ù–µ —Å—Ä–æ—á–Ω—ã–µ –∏ –Ω–µ –≤–∞–∂–Ω—ã–µ** - –£–¥–∞–ª–∏—Ç—å\n"
    )
    
    await update.message.reply_photo(
        photo=matrix_image,
        caption=caption,
        parse_mode='Markdown'
    )

async def show_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    cursor.execute('''
        SELECT 
            COUNT(*) as total_tasks,
            SUM(CASE WHEN is_completed THEN 1 ELSE 0 END) as completed_tasks,
            SUM(CASE WHEN is_completed = 0 THEN 1 ELSE 0 END) as pending_tasks
        FROM tasks 
        WHERE user_id = ?
    ''', (user_id,))
    
    total, completed, pending = cursor.fetchone()
    
    cursor.execute('''
        SELECT 
            category,
            COUNT(*) as total,
            SUM(CASE WHEN is_completed THEN 1 ELSE 0 END) as completed
        FROM tasks 
        WHERE user_id = ?
        GROUP BY category
    ''', (user_id,))
    
    category_stats = cursor.fetchall()
    conn.close()
    
    if total == 0:
        await update.message.reply_text(
            "üìä –£ —Ç–µ–±—è –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–¥–∞—á –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.\n\n"
            "–ù–∞—á–Ω–∏ –¥–æ–±–∞–≤–ª—è—Ç—å –∑–∞–¥–∞—á–∏ —á–µ—Ä–µ–∑ /add —á—Ç–æ–±—ã –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å —Å–≤–æ—é –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—å!"
        )
        return
    
    completion_rate = (completed / total) * 100 if total > 0 else 0
    
    message = f"üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏*\n\n"
    message += f"‚Ä¢ –í—Å–µ–≥–æ –∑–∞–¥–∞—á: {total}\n"
    message += f"‚Ä¢ –í—ã–ø–æ–ª–Ω–µ–Ω–æ: {completed}\n"
    message += f"‚Ä¢ –í –ø—Ä–æ—Ü–µ—Å—Å–µ: {pending}\n"
    message += f"‚Ä¢ –ü—Ä–æ—Ü–µ–Ω—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {completion_rate:.1f}%\n\n"
    
    message += "*–ü–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º:*\n"
    for category, cat_total, cat_completed in category_stats:
        cat_completion = (cat_completed / cat_total) * 100 if cat_total > 0 else 0
        message += f"{CATEGORY_INFO[category]['name']}: {cat_completed}/{cat_total} ({cat_completion:.1f}%)\n"
    
    message += f"\nüí° *–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:*\n"
    if completion_rate < 50:
        message += "–°—Ç–∞—Ä–∞–π—Ç–µ—Å—å —Ñ–æ–∫—É—Å–∏—Ä–æ–≤–∞—Ç—å—Å—è –Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –∑–∞–¥–∞—á!"
    elif completion_rate < 80:
        message += "–•–æ—Ä–æ—à–∏–π –ø—Ä–æ–≥—Ä–µ—Å—Å! –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –≤ —Ç–æ–º –∂–µ –¥—É—Ö–µ!"
    else:
        message += "–û—Ç–ª–∏—á–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã! –í—ã –æ—á–µ–Ω—å –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ã!"
    
    await update.message.reply_text(message, parse_mode='Markdown')

async def complete_task_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    cursor.execute('''
        SELECT task_id, task_text, category 
        FROM tasks 
        WHERE user_id = ? AND is_completed = FALSE
        ORDER BY 
            CASE category
                WHEN 'important_urgent' THEN 1
                WHEN 'important_not_urgent' THEN 2
                WHEN 'not_important_urgent' THEN 3
                WHEN 'not_important_not_urgent' THEN 4
            END
        LIMIT 10
    ''', (user_id,))
    
    tasks = cursor.fetchall()
    conn.close()
    
    if not tasks:
        await update.message.reply_text("üéâ –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á –¥–ª—è –æ—Ç–º–µ—Ç–∫–∏!")
        return
    
    keyboard = []
    for task_id, task_text, category in tasks:
        display_text = task_text[:30] + '...' if len(task_text) > 30 else task_text
        button_text = f"{CATEGORY_INFO[category]['name'][:2]} {display_text}"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"complete_{task_id}")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "‚úÖ –í—ã–±–µ—Ä–∏ –∑–∞–¥–∞—á—É –¥–ª—è –æ—Ç–º–µ—Ç–∫–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è:",
        reply_markup=reply_markup
    )

async def manage_reminders(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("‚è∞ 07:00 –£—Ç—Ä–æ", callback_data="reminder_07:00")],
        [InlineKeyboardButton("üèÉ 09:00 –ù–∞—á–∞–ª–æ –¥–Ω—è", callback_data="reminder_09:00")],
        [InlineKeyboardButton("‚òï 12:00 –û–±–µ–¥", callback_data="reminder_12:00")],
        [InlineKeyboardButton("üíº 15:00 –ü–æ—Å–ª–µ –æ–±–µ–¥–∞", callback_data="reminder_15:00")],
        [InlineKeyboardButton("üåá 18:00 –í–µ—á–µ—Ä", callback_data="reminder_18:00")],
        [InlineKeyboardButton("üîï –í—ã–∫–ª—é—á–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è", callback_data="reminder_off")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "‚è∞ *–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π*\n\n"
        "–í—ã–±–µ—Ä–∏ –≤—Ä–µ–º—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ —Ç–≤–æ–∏—Ö –∑–∞–¥–∞—á–∞—Ö:",
        parse_mode='Markdown',
        reply_markup=reply_markup
    )

async def send_daily_reminder(context: ContextTypes.DEFAULT_TYPE):
    job = context.job
    user_id = job.data
    
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    cursor.execute("SELECT reminder_time FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    
    if not result or result[0] == 'off':
        conn.close()
        return
    
    cursor.execute('''
        SELECT category, COUNT(*) 
        FROM tasks 
        WHERE user_id = ? AND is_completed = FALSE
        GROUP BY category
    ''', (user_id,))
    
    task_counts = cursor.fetchall()
    conn.close()
    
    if not task_counts:
        return
    
    message = "‚è∞ *–ï–∂–µ–¥–Ω–µ–≤–Ω–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ!*\n\n*–¢–≤–æ–∏ —Ç–µ–∫—É—â–∏–µ –∑–∞–¥–∞—á–∏:*\n"
    
    total_tasks = 0
    for category, count in task_counts:
        message += f"{CATEGORY_INFO[category]['name']}: {count} –∑–∞–¥–∞—á\n"
        total_tasks += count
    
    quote = get_daily_quote()
    message += f"\n*–í—Å–µ–≥–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á: {total_tasks}*\n"
    message += f"\nüí° *–°–æ–≤–µ—Ç:* –ù–∞—á–Ω–∏ —Å –≤–∞–∂–Ω—ã—Ö –∏ —Å—Ä–æ—á–Ω—ã—Ö –∑–∞–¥–∞—á!\n\n"
    message += f"*–ú–æ—Ç–∏–≤–∞—Ü–∏—è –Ω–∞ —Å–µ–≥–æ–¥–Ω—è:*\n{quote}"
    
    try:
        await context.bot.send_message(chat_id=user_id, text=message, parse_mode='Markdown')
    except Exception as e:
        logger.error(f"Error sending reminder to {user_id}: {e}")

# ===== –û–°–ù–û–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø =====
def main():
    init_db()
    
    application = Application.builder().token(BOT_TOKEN).build()
    
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("quote", show_quote))
    application.add_handler(CommandHandler("add", add_task))
    application.add_handler(CommandHandler("tasks", show_tasks))
    application.add_handler(CommandHandler("matrix", show_matrix))
    application.add_handler(CommandHandler("stats", show_stats))
    application.add_handler(CommandHandler("complete", complete_task_command))
    application.add_handler(CommandHandler("reminders", manage_reminders))
    application.add_handler(CommandHandler("categories", show_categories))
    
    application.add_handler(CallbackQueryHandler(button_handler, pattern="^(category_|explain_categories|back_to_categories|complete_)"))
    application.add_handler(CallbackQueryHandler(handle_deadline_selection, pattern="^deadline_"))
    application.add_handler(CallbackQueryHandler(set_reminder_time, pattern="^reminder_"))
    
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_task_text))
    
    scheduler = BackgroundScheduler()
    scheduler.add_jobstore('sqlalchemy', url=f'sqlite:///{DB_PATH}_jobs')
    
    scheduler.add_job(
        send_daily_reminder,
        'cron',
        hour=9,
        minute=0,
        args=[application],
        id='daily_reminder'
    )
    
    scheduler.start()
    
    print("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω...")
    application.run_polling()

if __name__ == "__main__":
    main()
